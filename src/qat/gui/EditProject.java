package qat.gui;/** * * @author Stephen Kruger * @version 2.3, 17 June 1999 */import javax.swing.*;import javax.swing.border.*;import javax.swing.text.*;import java.util.*;import java.io.*;import java.awt.*;import java.awt.event.*;import qat.common.*;import qat.components.*;public class EditProject extends JDialog implements ActionListener {    Properties projectProperties;    Properties originalProperties;    Properties keyWordHistoryProperties;    Properties agentProperties;    Hashtable actions;    JTextField testDirectoryPath;    JButton browseButton;    JTextArea projectPropertiesTextArea;    JTextArea systemPropertiesTextArea;    JCheckBox autosave, reuseTraceWindow, syntaxHighlighting, resetStatus;    EComboBox parserClassName, testfinderClassName, pluginClassNames;    JComboBox lookAndFeel;    ComboText httpPort;    ComboText bufferSize;    ComboText debugLevel;    private boolean reloadTests = false;    private String agentCount, propertiesVersion;    private JPanel guiPanel;    private ArrayList guiComponents;    private JScrollPane guiPanelPane;    private QAT parent;    private JTabbedPane tabbedPane;	    public EditProject(QAT parent, Properties p, String title) {	super(parent,Resources.getString("projectSettings"),true);	this.parent = parent;	setupScreen();	chargeProperties(p);	pack();	setSize(640,480);	SwingUtils.setLocationRelativeTo(this,parent);	setVisible(true);    }	    private static Properties tempFunc(Properties p, String newKey, String oldKey, String defaultVal) {	p.setProperty(newKey,p.getProperty(oldKey,defaultVal));	p.remove(oldKey);	return p;    }    private void chargeGuiProperties(Properties p) {	ArrayList components1 = new ArrayList();	ArrayList components2 = new ArrayList();	ArrayList components3 = new ArrayList();	guiPanel.removeAll();	String key, name, value, values;	JComponent c;	for (Enumeration e = p.propertyNames() ; e.hasMoreElements() ;) {	    key = ((String)e.nextElement());	    key = key.trim();	    try {		if (key.startsWith("qat.project.guiproperty.checkbox")) {		    name = key.substring(33,key.length());		    value = (String)p.get(key);		    components1.add(c = new JCheckBox(name, Boolean.valueOf(value).booleanValue()));		    c.setToolTipText(key);		}		if (key.startsWith("qat.project.guiproperty.textfield")) {		    name = key.substring(34,key.length());		    value = (String)p.get(key);		    components3.add(c = new ComboText(name, value));		    c.setToolTipText(key);		}		if ((key.startsWith("qat.project.guiproperty.combobox"))&&		    (key.indexOf(".values")<0)) {		    name = key.substring(33,key.length());		    value = (String)p.get(key);		    values = (String)p.getProperty(key+".values",value);		    components2.add(c = new ComboList(name, value, values));		    c.setToolTipText(key);		}	    }	    catch (Throwable t) {		System.out.println("Error processing key:"+key);	    }	}	BoxLayout layout;			guiComponents = new ArrayList();	JPanel guiPanel1 = new JPanel(new GridLayout(components1.size()/2,2));	guiPanel1.setBorder(BorderFactory.createEtchedBorder());	for (int i = 0; i < components1.size(); i++) {	    guiPanel1.add((JComponent)components1.get(i));	    guiComponents.add(components1.get(i));	}	JPanel guiPanel2 = new JPanel(new GridLayout(components2.size()/2,2));	guiPanel2.setBorder(BorderFactory.createEtchedBorder());	for (int i = 0; i < components2.size(); i++) {	    guiPanel2.add((JComponent)components2.get(i));	    guiComponents.add(components2.get(i));	}	JPanel guiPanel3 = new JPanel();	guiPanel3.setBorder(BorderFactory.createEtchedBorder());	guiPanel3.setLayout(new BoxLayout(guiPanel3,BoxLayout.Y_AXIS));	for (int i = 0; i < components3.size(); i++) {	    guiPanel3.add((JComponent)components3.get(i));	    guiComponents.add(components3.get(i));	}	guiPanel.add(guiPanel1);	guiPanel.add(guiPanel2);	guiPanel.add(guiPanel3);	guiPanelPane.validate();	// don't display it if it's empty	if (guiComponents.size()==0)	    tabbedPane.remove(guiPanelPane);    }	    /**     * This will commit the user-selected gui properties into the     * properties file. The properties tab being displayed will take precedence.     */    private void collectGuiProperties(Properties p) {	for (int i = 0; i < guiComponents.size(); i++) {	    if (guiComponents.get(i) instanceof JCheckBox) {		p.put(((JCheckBox)guiComponents.get(i)).getToolTipText(),		      new Boolean(((JCheckBox)guiComponents.get(i)).isSelected()).toString());	    }	    if (guiComponents.get(i) instanceof ComboText) {		p.put(((ComboText)guiComponents.get(i)).getToolTipText(),		      ((ComboText)guiComponents.get(i)).getText());	    }	    if (guiComponents.get(i) instanceof ComboList) {		p.put(((ComboList)guiComponents.get(i)).getToolTipText()+".values",		      ((ComboList)guiComponents.get(i)).getText());		p.put(((ComboList)guiComponents.get(i)).getToolTipText(),		      ((ComboList)guiComponents.get(i)).getValue());	    }	}    }	    /**     * Skim all the non-user stuff from the properties and set up the components     * which use it.     */    private void chargeProperties(Properties p) {	chargeGuiProperties(p);	systemPropertiesTextArea.setEditable(true);	String name;	// clone the passed properties in case user chooses cancel	originalProperties = p; // keep a copy of them.	projectProperties = Utils.mergeProperties(new Properties(),p);	projectProperties =(Properties)p.clone();			// remove the reuseTraceWindow property	reuseTraceWindow.setSelected(new Boolean(projectProperties.getProperty(Common.REUSE_TRACE_WINDOW,"true")).booleanValue());	projectProperties.remove(Common.REUSE_TRACE_WINDOW);			// remove the http port property	httpPort.setText(projectProperties.getProperty(Common.HTTP_PORT_KEY,Common.HTTP_PORT_DEFAULT));	projectProperties.remove(Common.HTTP_PORT_KEY);			// remove the autosave property	autosave.setSelected(new Boolean(projectProperties.getProperty(Common.AUTOSAVE_PROJECT,"true")).booleanValue());	projectProperties.remove(Common.AUTOSAVE_PROJECT);			// remove the syntaxHighlighting property	syntaxHighlighting.setSelected(new Boolean(projectProperties.getProperty(Common.SYNTAX_HIGHLIGHTING,"true")).booleanValue());	projectProperties.remove(Common.SYNTAX_HIGHLIGHTING);			// remove the console buffer size property	bufferSize.setText(projectProperties.getProperty(Common.CONSOLE_BUFFER_SIZE,							 Common.CONSOLE_BUFFER_SIZE_VALUE));	projectProperties.remove(Common.CONSOLE_BUFFER_SIZE);			// remove the console debug level property	debugLevel.setText(projectProperties.getProperty(Common.CONSOLE_DEBUG_LEVEL,							 Common.CONSOLE_DEBUG_LEVEL_VALUE));	projectProperties.remove(Common.CONSOLE_DEBUG_LEVEL);			// remove the resetStatus property	resetStatus.setSelected(new Boolean(projectProperties.getProperty(Common.RESET_STATUS,"true")).booleanValue());	projectProperties.remove(Common.RESET_STATUS);			// remove the default parser class name property	parserClassName.setList(projectProperties.getProperty(Common.PARSER_CLASSNAMES,							      Common.DEFAULT_PARSER_CLASSNAMES));	projectProperties.remove(Common.PARSER_CLASSNAMES);			// remove the default testfinder class name property	testfinderClassName.setList(projectProperties.getProperty(Common.TESTFINDER_CLASSNAMES,								  Common.DEFAULT_TESTFINDER_CLASSNAMES));	projectProperties.remove(Common.TESTFINDER_CLASSNAMES);			// remove the plugin class list	pluginClassNames.setList(projectProperties.getProperty(Common.PLUGIN_CLASSES));	projectProperties.remove(Common.PLUGIN_CLASSES);			// remove the test directory path keyword	testDirectoryPath.setText(projectProperties.getProperty(Common.PROJECTPATH_KEY,"."));	systemPropertiesTextArea.append(Common.PROJECTPATH_KEY+"="+projectProperties.getProperty(Common.PROJECTPATH_KEY,"")+System.getProperty("line.separator"));	projectProperties.remove(Common.PROJECTPATH_KEY);			// remove the AGENT_COUNT property	agentCount = projectProperties.getProperty(Common.AGENT_COUNT,"0");	systemPropertiesTextArea.append(Common.AGENT_COUNT+"="+agentCount+System.getProperty("line.separator"));	projectProperties.remove(Common.AGENT_COUNT);			// remove the properties version property	propertiesVersion = projectProperties.getProperty(Common.PROPERTIES_VERSION,Common.CURRENT_PROPERTIES_VERSION);	systemPropertiesTextArea.append(Common.PROPERTIES_VERSION+"="+propertiesVersion+System.getProperty("line.separator"));	projectProperties.remove(Common.PROPERTIES_VERSION);			// remove the LOOK_AND_FEEL_KEY property	projectProperties.remove(Common.LOOK_AND_FEEL_KEY);			// remove keyword history and AGENT1_NAME etc stuff	keyWordHistoryProperties = new Properties();	agentProperties = new Properties();	for (Enumeration e = projectProperties.propertyNames() ; e.hasMoreElements() ;) {	    name = (String)e.nextElement();	    // remove and save keyword history stuff	    if (name.indexOf("KeyWordHistory")==0) {		keyWordHistoryProperties.setProperty(name,projectProperties.getProperty(name));		projectProperties.remove(name);	    }	    // remove and save AGENT_XXXX system stuff	    if (name.indexOf(Common.host)==0) {		if ((name.indexOf(Common.hostNamePattern)>0)||		    (name.indexOf(Common.hostPortPattern)>0)||		    (name.indexOf(Common.hostArchPattern)>0)||		    (name.indexOf(Common.hostOSPattern)>0)) {		    agentProperties.setProperty(name,projectProperties.getProperty(name));		    projectProperties.remove(name);		}	    }				}			// copy the user properties to this text area	ArrayList elements = new ArrayList();	for (Enumeration e = projectProperties.propertyNames() ; e.hasMoreElements() ;) {	    name = (String)e.nextElement();	    elements.add(name+"="+projectProperties.getProperty(name)+System.getProperty("line.separator"));	}	Object parray[] = elements.toArray();	Arrays.sort(parray);	for (int i = 0; i < parray.length; i++)	    projectPropertiesTextArea.append((String)parray[i]);			systemPropertiesTextArea.setEditable(false);    }	    /**     * Collects all the properties from the GUI components and returns them in     * a Properties object for use as a project.     */    private void collectProperties() {	// copy the text area properties into our properties object	projectProperties = new Properties();	StringTokenizer propPair;	StringTokenizer token = new StringTokenizer(projectPropertiesTextArea.getText(),System.getProperty("line.separator"));	String s ="";	while (token.hasMoreTokens()) {	    propPair = new StringTokenizer(token.nextToken(),"=");	    try {		projectProperties.put(s = propPair.nextToken(),propPair.nextToken());	    }	    catch (java.util.NoSuchElementException ex) {		System.out.println("Warning - Undefined property encountered:"+s);		    }	}			// restore the keyword info	Utils.mergeProperties(projectProperties,keyWordHistoryProperties);	// restore the agent info	Utils.mergeProperties(projectProperties,agentProperties);			// restore the reuse trace files window in tree property	projectProperties.setProperty(Common.REUSE_TRACE_WINDOW,				      new Boolean(reuseTraceWindow.isSelected()).toString());			// restore the autosave property	projectProperties.setProperty(Common.AUTOSAVE_PROJECT,				      new Boolean(autosave.isSelected()).toString());			// restore the http port property	projectProperties.setProperty(Common.HTTP_PORT_KEY,				      httpPort.getText());			// restore the syntaxHighlighting in tree property	projectProperties.setProperty(Common.SYNTAX_HIGHLIGHTING,				      new Boolean(syntaxHighlighting.isSelected()).toString());			// restore the resetStatus in tree property	projectProperties.setProperty(Common.RESET_STATUS,				      new Boolean(resetStatus.isSelected()).toString());			// restore the default parser class name	projectProperties.setProperty(Common.PARSER_CLASSNAMES,				      parserClassName.getList());			// restore the plugin class list	projectProperties.setProperty(Common.PLUGIN_CLASSES,				      pluginClassNames.getList());			// restore the default testfinder class name	projectProperties.setProperty(Common.TESTFINDER_CLASSNAMES,				      testfinderClassName.getList());			// restore the test directory info	projectProperties.setProperty(Common.PROJECTPATH_KEY,    testDirectoryPath.getText());			// restore the AGENT_COUNT property	projectProperties.setProperty(Common.AGENT_COUNT,agentCount);			// restore the PROPERTIES_VERSION property	projectProperties.setProperty(Common.PROPERTIES_VERSION,propertiesVersion);					// restore the CONSOLE_BUFFER_SIZE property	projectProperties.setProperty(Common.CONSOLE_BUFFER_SIZE,bufferSize.getText());			// restore the CONSOLE_DEBUG_LEVEL property	projectProperties.setProperty(Common.CONSOLE_DEBUG_LEVEL,debugLevel.getText());			// decide whether the tests need to be reloaded or not	if ((!originalProperties.getProperty(Common.PROJECTPATH_KEY,"").equals(projectProperties.getProperty(Common.PROJECTPATH_KEY)))||	    (!originalProperties.getProperty(Common.PARSER_CLASSNAMES,"").equals(projectProperties.getProperty(Common.PARSER_CLASSNAMES))) )	    reloadTests = true;			// set up the selected look and feel	try {	    // restore the LOOK_AND_FEEL_KEY property	    projectProperties.setProperty(Common.LOOK_AND_FEEL_KEY,(String)lookAndFeel.getSelectedItem());	    UIManager.setLookAndFeel(projectProperties.getProperty(Common.LOOK_AND_FEEL_KEY));	    SwingUtilities.updateComponentTreeUI(parent);	}	catch (Exception e) {	    JOptionPane.showMessageDialog(this,					  e.toString(),					  Resources.getString("error"),					  JOptionPane.ERROR_MESSAGE);	}			// gui properties take precedence, but only if the tab is being displayed, else ignore	// the gui settings	if (tabbedPane.getTitleAt(tabbedPane.getSelectedIndex()).equals(Resources.getString("projectOptions"))) {	    collectGuiProperties(projectProperties);	}    }	    private void createActionTable(JTextComponent textComponent) {	actions = new Hashtable();	Action[] actionsArray = textComponent.getActions();	for (int i = 0; i < actionsArray.length; i++) {	    Action a = actionsArray[i];	    actions.put(a.getValue(Action.NAME), a);	}    }	    private Action getActionByName(String name) {	return (Action)(actions.get(name));    }	    private void setupScreen() {	JPanel temp;	JPanel main = new JPanel(new BorderLayout());	tabbedPane = new JTabbedPane();			// now add the new GUI config panel	guiPanel = new JPanel();	guiPanel.setLayout(new BoxLayout(guiPanel,BoxLayout.Y_AXIS));	tabbedPane.add(Resources.getString("projectOptions"),guiPanelPane = new JScrollPane(guiPanel,											    JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,											    JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED));			// the Project properties panel	JPanel propsPanel = new JPanel(new BorderLayout());	JScrollPane scrollPane = new JScrollPane(projectPropertiesTextArea = new JTextArea());        // FIX START        // When you define a property which is extremly long (e.g. CLASSPATH),        // the scrollPane is drawn to fit  in a way scroll bars are not needed;        // consequence is you get a fucking big window that goes out of screen limits !        // By setting the Dimension, I get an average result that looks good.        scrollPane.setPreferredSize(new Dimension(600,350)) ;   // fix jqat.00018.E        // FIX END	temp = new JPanel(new GridLayout(1,1));	temp.setBorder(BorderFactory.createTitledBorder(Resources.getString("projectProperties")));	temp.add(scrollPane);	propsPanel.add(temp,BorderLayout.CENTER);	scrollPane = new JScrollPane(systemPropertiesTextArea = new JTextArea());	temp = new JPanel(new GridLayout(1,1));	temp.setBorder(BorderFactory.createTitledBorder(Resources.getString("systemProperties")));	temp.add(scrollPane);	propsPanel.add(temp,BorderLayout.SOUTH);	tabbedPane.add(Resources.getString("projectProperties"),propsPanel);					// the Project Settings panel	JPanel centerPanel = new JPanel();	centerPanel.setLayout(new BoxLayout(centerPanel,BoxLayout.Y_AXIS));			temp = new JPanel(new GridLayout(3,1));	temp.setBorder(BorderFactory.createTitledBorder(Resources.getString("userDefinedClasses")));			// add the Parser Class edit field	temp.add(parserClassName = new EComboBox());	parserClassName.setEditable(true);			// add the TestFinder Class edit field	temp.add(testfinderClassName = new EComboBox());	testfinderClassName.setEditable(true);			// add the Plugin Class edit field	JPanel tmp2 = new JPanel(new GridLayout(1,2));	tmp2.add(new JLabel(Resources.getString("pluginClassName"),SwingConstants.CENTER));	tmp2.add(pluginClassNames = new EComboBox());	pluginClassNames.setEditable(true);	temp.add(tmp2);	centerPanel.add(temp);			// add the miscOptions pane	temp = new JPanel(new GridLayout(4,2));	temp.setBorder(BorderFactory.createTitledBorder(Resources.getString("miscOptions")));	temp.add(autosave = new JCheckBox(Resources.getString("autosave")));	temp.add(reuseTraceWindow = new JCheckBox(Resources.getString("reuseTraceWindow")));	temp.add(syntaxHighlighting = new JCheckBox(Resources.getString("syntaxHighlighting")));	temp.add(resetStatus = new JCheckBox(Resources.getString("resetStatus")));			JPanel t;	// console buffer size	temp.add(bufferSize = new ComboText(Resources.getString("bufferSizeLabel"),6),BorderLayout.WEST);			// console debug level	temp.add(debugLevel = new ComboText(Resources.getString("debugLevelLabel"),6),BorderLayout.WEST);			// look and feel	t = new JPanel(new BorderLayout());	temp.add(new JLabel(Resources.getString("lookAndFeel"),SwingConstants.CENTER));	javax.swing.UIManager.LookAndFeelInfo installed[] = UIManager.getInstalledLookAndFeels();	String lfNames[] = new String[installed.length];	for (int i = 0; i < installed.length; i++)	    lfNames[i] = installed[i].getClassName();	t.add(lookAndFeel = new JComboBox(lfNames));	lookAndFeel.setSelectedItem(UIManager.getLookAndFeel().getClass().getName());	temp.add(t);			centerPanel.add(temp);			// add the test path panel	temp = new JPanel(new GridLayout(2,1));	temp.setBorder(BorderFactory.createTitledBorder(Resources.getString("testSettings")));			// test path	t = new JPanel(new BorderLayout());	JPanel t2 = new JPanel(new FlowLayout());	t.add(new JLabel(Resources.getString("testPath")),BorderLayout.WEST);	t.add(testDirectoryPath = new JTextField(35),BorderLayout.CENTER);	t.add(browseButton = new JButton(Resources.getString("browse")),BorderLayout.EAST);	t2.add(t);	temp.add(t2);	// http port	temp.add(httpPort = new ComboText(Resources.getString("httpPort"),5));			browseButton.addActionListener(this);	centerPanel.add(temp);			tabbedPane.add(Resources.getString("projectSettings"),centerPanel);			JPanel south = new JPanel();	JButton button;	south.add(button = new JButton(Resources.getString("ok")));	button.addActionListener(this);	south.add(button = new JButton(Resources.getString("cancel")));	button.addActionListener(this);	main.add(tabbedPane,BorderLayout.CENTER);	main.add(south,BorderLayout.SOUTH);	getContentPane().add(main);    }	    public void actionPerformed(ActionEvent e) {	if (e.getSource() instanceof JButton) {	    // ok	    if (((JButton)e.getSource()).getText().equals(Resources.getString("ok"))) {		setVisible(false);		collectProperties();		parent.editProjectCallback(this);		return;	    }	    if (e.getSource()==browseButton) {		JFileChooser testDir = new JFileChooser(testDirectoryPath.getText());		testDir.setDialogTitle(Resources.getString("selectTestDir"));		testDir.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);					try {		    if (testDir.showOpenDialog(this)==JFileChooser.APPROVE_OPTION) {			testDirectoryPath.setText(testDir.getSelectedFile().getCanonicalPath());		    }		}		catch (Exception ex) {		    System.out.println("Unexpected error loading test directory");		}		return;	    }	    // cancel	    if (((JButton)e.getSource()).getText().equals(Resources.getString("cancel"))) {		setVisible(false);		projectProperties = originalProperties;// cancels any changes		return;	    }	}    }	    public Properties getProperties() {	return projectProperties;    }	    public boolean needToReloadTests() {	return reloadTests;    }}