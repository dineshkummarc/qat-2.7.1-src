package qat.parser;/** * * @author webhiker * @version 2.3, 17 June 1999 * */import java.io.*;import java.net.*;import java.util.*;// qat importsimport qat.common.ProtocolConstants;import qat.common.TestObject;import qat.common.Utils;import qat.common.Common;public class AgentInstance extends Object {    private static final String RESPONSE_OK_ERROR="Error waiting for response finished message";    private static final String RESPONSE_PROCESSING_ERROR="Error waiting for response processing message";    private String agentName;    private int agentPort;    private String agentWorkDir;    private boolean cleanWorkDir; // if we had to create the work dir, we must delete it when finished    private Hashtable executeRequests;    private Hashtable zipRequests;    private Properties environment;    private boolean pEvaluationMode;	    // these are variables opened and closed for each command    Socket socket;    DataInputStream inStr;    DataOutputStream outStr;	    /**     * This sets up an instance for communicating with an agent.     * @param name the name of the agent machine     * @param port the port of the agent machine to connect to     * @param dir a dir path on the agent machine which will be used as a base     * to store any temporary files. This dir will be deleted by a call to DELAGENT     * @param mode if true, evaluation mode is selected, and no communication is actually     * required with an agent. Otherwise, a live agent is expected.     */    public AgentInstance(String name, int port, String dir, boolean mode) throws Exception {	setEvaluationMode(mode);	setAgentName(name);	setAgentPort(port);	setAgentWorkDirectory(dir);	executeRequests = new Hashtable();	zipRequests = new Hashtable();	environment = new Properties();    }	    /**     * Returns true if this agent instance is currently in evaluation mode, else it returns false.     */    public boolean inEvaluationMode() {	return pEvaluationMode;    }	    /**     * Sets this agent instance to evaluation mode, else it returns false.     * If true, evaluation mode is selected, and no communication is actually     * required with an agent. Otherwise, a live agent is expected.     * @param mode if true, evaluation mode is activated.     */	    public void setEvaluationMode(boolean mode) {	this.pEvaluationMode = mode;    }	    /**     * This returns the name of the machine corresponding to this agent instance.     */    public String getAgentName() {	return agentName;    }	    /**     * This sets the name of the machine corresponding to this agent instance.     * @param name the name of the agent machine     */    public void setAgentName(String name) {	agentName = name;    }	    /**     * This returns the port of the machine running the agent corresponding to this agent instance.     */    public int getAgentPort() {	return agentPort;    }	    /**     * This sets the name of the machine corresponding to this agent instance.     * @param port the port on the agent machine     */	    public void setAgentPort(int port) {	agentPort = port;    }	    /**     * This returns the working directory of the agent corresponding to      * this agent instance.     */    public String getAgentWorkDirectory() {	return agentWorkDir;    }	    /**     * This sets the working directory of the agent corresponding to this agent instance.     * This should normally be done only once per agent instance.     * If the dir does not exist on the agent, it will be created, and then deleted     * by the matching call to DELAGENT. If it already exists, it will not be deleted by a call to     * DELAGENT.     * @param dir the name of the working directory on the agent machine     */    public void setAgentWorkDirectory(String dir) throws Exception {	agentWorkDir = dir;	cleanWorkDir = !(CHECKFILE(dir).equals("0"));	if (!inEvaluationMode()) {	    try {		// only create it if it doesn't already exist		if (cleanWorkDir)		    MKDIR(dir);	    }	    catch (Exception e) {		// this is thrown if the dir already exists,		// so we don't mind too much.	    }	}    }	    //	public void setProperty(String key, String value) {    //		environment.setProperty(key,value);    //	}	    /**     * Looks through currently running processes for an identifier matching processID.     * Returns the true if it was found.     * @param processID the processID to look for     */    public boolean isHandlingProcess(String processID) {	return (executeRequests.get(new Integer(processID))!=null);       }	    /**     * Looks through sent zip lists for an identifier matching zipID.     * Returns the true if it was found.     * @param zipID the zipID to look for     */    public boolean isHandlingZip(String zipID) {	return (zipRequests.get( zipID )!=null);    }	    /**      * This method is called to clean up any trace, stdout & stderror files created     * by calls to STARTCMD.     */    public void DELAGENT() throws Exception {	Integer processID;	// cleanup any running processes	for (Enumeration e = executeRequests.keys() ; e.hasMoreElements() ;) {	    processID = (Integer)e.nextElement();	    // stop any started processes	    try {		CMDSTOP(processID.toString());	    }	    catch (Exception ex) {	    }	    // clean any left over trace files	    try {		CMDCLEAN(processID.toString());	    }	    catch (Exception ex) {	    }	}	// delete the agent temp directory and any files left in it	// only if we created the directory in the first place.	if (cleanWorkDir) {	    try {		DELFILE(agentWorkDir);	    }	    catch (Exception ex) {	    }		}			// try to clean up daemon processes on the agent	DAEMONCLEAN();    }	    /**     * This code is done in a method to save repeated code segments.     */    private synchronized void openAgentSocket() throws IOException {	socket = new Socket(agentName, new Integer(agentPort).intValue());	socket.setSoTimeout(ProtocolConstants.SOCKET_TIMEOUT);	inStr= new DataInputStream(socket.getInputStream());	outStr= new DataOutputStream(socket.getOutputStream());    }	    private synchronized void closeAgentSocket() throws IOException {	inStr.close();	outStr.flush();	outStr.close();	socket.close();    }	    /**     * Sends a zip file to the agent machine, places it in the working directory,     * and unzips it.     * Returns a zipID for use for future deletion.     * @param zipFile the local path to the zip file.     * @return the zipID for later reference and deletion     */    public String ZIPSEND(String zipFile, String zipID) throws Exception {	if (!inEvaluationMode()) {	    // first check if the file exists	    File file = new File(zipFile);	    if (!file.exists())		throw new Exception("Zip file does not exist :"+zipFile);	    /* Open a socket with the Agent */	    try {		openAgentSocket();				// send the action code		outStr.writeInt(ProtocolConstants.ZIP_SEND_REQUEST);		// send the workDirectory to place/unzip the zip file		outStr.writeUTF(agentWorkDir);		// send the name of the zip file, with no path information		outStr.writeUTF(Utils.extractFileName(zipFile));		outStr.flush();				// open the zip file to read		BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));				/* send the file length */		outStr.writeLong(file.length());				/* sends the zip content */		BufferedOutputStream outBuffStr = new BufferedOutputStream(outStr);		int bytesRead=0, counter=0;		long size = file.length();		byte buff[] = new byte[1024];		while ((bytesRead>=0)&&(counter < size)) {		    bytesRead = in.read(buff,0,buff.length);		    if (bytesRead>0)			outBuffStr.write(buff,0,bytesRead);		    counter+= bytesRead;		}		outBuffStr.flush();		in.close();				expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);	    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	zipRequests.put(zipID, agentWorkDir+">>"+Utils.extractFileName(zipFile));	return zipID;    }    /**     * Sends a zip file to the agent machine, places it in the working directory,     * and unzips it.     * Returns a zipID for use for future deletion.     * @param zipFile the local path to the zip file.     * @return the zipID for later reference and deletion     */    public String ZIPSEND(String zipFile) throws Exception {	return ZIPSEND(zipFile,Integer.toString(Utils.getUniqueID()));    }        /**     * This method cleans a zip file previously sent to the agent matching this agent instance.     * @param zipRequestID the id returned when the ZIPSEND command was called     */    public void ZIPCLEAN(String zipID) throws Exception {	String zipRequestString = (String)zipRequests.get(zipID);	if (zipRequestString==null)	    throw new Exception("unknown zip ID  :"+zipID);	String workDir = zipRequestString.substring(0,zipRequestString.indexOf(">>"));	String zipFileName = zipRequestString.substring(zipRequestString.indexOf(">>")+2,zipRequestString.length());				/* Open a socket with the Agent */	if (!inEvaluationMode()) {			    try {		openAgentSocket();						// send the action code		outStr.writeInt(ProtocolConstants.ZIP_CLEAN_REQUEST);		// send the workDirectory to place/unzip the zip file		outStr.writeUTF(workDir);		outStr.writeUTF(zipFileName);						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);	    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	zipRequests.remove(zipID);    }	    /**     * This sets a property which will be visible to any process executed on the agent     * machine by this agent instance.     * @param key the key of the key-property pair     * @param value the value of the key-value pair     */    public void SETPROP(String key, String value) {	environment.setProperty(key,value);    }	    /**     * This deletes a property previously set by a call to SETPROP.     * so that future execution commands will no longer have this variable set in their environment.     * This will not affect processes already started.     */    public void DELPROP(String key, String value) {	environment.remove(key);    }	    /**     * This starts a command on the agent corresponding to this agent instance.     * @param command command to be started, relative to the agent     * @param timeout the timeout, in seconds, afeter which a call to GETSTATUS will     * return failed.     * @return an processID used for future queries on the process state, trace file      * retrieval etc.     */	     public String CMDSTART(String command[], String timeout) throws Exception {	int uniqueID = Utils.getUniqueID();	String returnVal = Integer.toString(uniqueID);	String testName = environment.getProperty("TEST_NAME","NO_NAME_DEFINED")+uniqueID;			if (!inEvaluationMode()) {	    try {		/* Open a socket with the Agent */		openAgentSocket();						TestObject test = new TestObject(Integer.toString(uniqueID),						 command, 						 environment, 						 agentWorkDir, 						 new Integer(timeout).intValue());		/* send the CMDSTART_REQUEST command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.CMDSTART_REQUEST);		test.writeObject(outStr);		outStr.flush();						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);						// no exceptions thrown yet, so		// record what file was sent and where it was sent to		executeRequests.put(new Integer(uniqueID),test);	    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	else {	    // simulate a process ID for evaluation mode	    executeRequests.put(new Integer(uniqueID),				new TestObject(Integer.toString(uniqueID),					       command, 					       environment, 					       agentWorkDir, 					       new Integer(timeout).intValue()));	}	return returnVal;    }	    /**     * If the process is still running, it will be killed and the return will be     * negative, else if it wasn't running, the exit status will be returned.     */    public String CMDSTOP(String processID) throws Exception {	int status = 0;	if (!inEvaluationMode()) {	    try {		/* Open a socket with the Agent */		openAgentSocket();						TestObject test = (TestObject)executeRequests.get(new Integer(processID));						/* send the CMDSTOP_REQUEST command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.CMDSTOP_REQUEST);		test.writeObject(outStr);		outStr.flush();		expectCode(ProtocolConstants.RESPONSE_PROCESSING,  RESPONSE_PROCESSING_ERROR);							/* get the remote process exit status, and acknowledgment */		status = inStr.readInt();						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK, RESPONSE_OK_ERROR);	    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	return Integer.toString(status);    }	    public String CMDSTATUS(String processID) throws Exception {	int status = 0;	if (!inEvaluationMode()) {	    try {		/* Open a socket with the Agent */		openAgentSocket();					TestObject test = (TestObject)executeRequests.get(new Integer(processID));						/* send the CMDSTATUS command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.CMDSTATUS_REQUEST);		test.writeObject(outStr);						expectCode(ProtocolConstants.RESPONSE_PROCESSING,  RESPONSE_PROCESSING_ERROR);							/* get the remote process exit status, and acknowledgment */		status = inStr.readInt();						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK, RESPONSE_OK_ERROR);					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	return Integer.toString(status);    }	    /**     * This starts a command on the agent corresponding to this agent instance.     * @param command command to be started, relative to the agent     * @param timeout the timeout, in seconds, afeter which a call to GETSTATUS will     * return failed.     * @return an processID used for future queries on the process state, trace file      * retrieval etc.     */	     public void DAEMONSTART(String command[]) throws Exception {	int uniqueID = Utils.getUniqueID();	String testName = environment.getProperty("TEST_NAME","NO_NAME_DEFINED")+uniqueID;			if (!inEvaluationMode()) {	    try {		/* Open a socket with the Agent */		openAgentSocket();						TestObject test = new TestObject(Integer.toString(uniqueID),						 command, 						 environment, 						 agentWorkDir, 						 0); // timeout		/* send the DAEMONSTART_REQUEST command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.DAEMONSTART_REQUEST);		test.writeObject(outStr);		outStr.flush();						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);	    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}		    }	    public void GETFILE(String src, String dest) throws Exception {	/* Open a socket with the Agent */	if (!inEvaluationMode()) {			    try {		openAgentSocket();						// send the action code		outStr.writeInt(ProtocolConstants.GETFILE);						// send the name of the desired file		outStr.writeUTF(src);						// the recieveFile will eat the PROCCESING OK response, so don't handle it here.		recieveFile(dest,inStr,outStr);					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }			}    }	    public void SENDFILE(String src, String dest) throws Exception {	/* Open a socket with the Agent */	if (!inEvaluationMode()) {	    try {		openAgentSocket();						// send the action code		outStr.writeInt(ProtocolConstants.SENDFILE);						// send the name of the desired file		outStr.writeUTF(dest);						sendFile(src,inStr,outStr);		// the sendFile will eat the PROCCESING OK response, so don't handle it here.					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}    }	    /**     * This method returns "0" if filename exists, and "1" if it doesn't.     */    public String CHECKFILE(String filename) throws Exception {	int status = 0;	if (!inEvaluationMode()) {	    try {		// Open a socket with the Agent 		openAgentSocket();						// send the CHECKFILE command		outStr.writeInt(ProtocolConstants.CHECKFILE);		outStr.writeUTF(filename);		outStr.flush();		int code;		// read the value, 0 = file exists, 1 = file does not exist		status = inStr.readInt();					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	return Integer.toString(status);    }    public void DELFILE(String filename) throws Exception {	/* Open a socket with the Agent */	if (!inEvaluationMode()) {			    try {		openAgentSocket();				// send the action code		outStr.writeInt(ProtocolConstants.DELFILE);		// send the name of the file to be deleted		outStr.writeUTF(filename);						int code;		if ((code=inStr.readInt()) != ProtocolConstants.RESPONSE_FINISHED_OK) {		    throw new Exception("Did not recieve RESPONSE_OK from the agent :"+code);		}					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }		}    }	    public void MKDIR(String filename) throws Exception {	/* Open a socket with the Agent */	if (!inEvaluationMode()) {			    try {		openAgentSocket();						// send the action code		outStr.writeInt(ProtocolConstants.MKDIR);		// send the name of the dir to be created		outStr.writeUTF(filename);						int code;		if ((code=inStr.readInt()) != ProtocolConstants.RESPONSE_FINISHED_OK) {		    throw new Exception("Did not recieve RESPONSE_OK from the agent :"+code);		}					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}    }		    public String CMDGETTRACE(String processID, String fileName) throws Exception {	int status = 0;	if (!inEvaluationMode()) {	    try {		/* Open a socket with the Agent */		openAgentSocket();						TestObject test = (TestObject)executeRequests.get(new Integer(processID));						/* send the CMDGETTRACE command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.CMDGETTRACE_REQUEST);		test.writeObject(outStr);		outStr.flush();						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);										// recieve the stdout and stderr files		recieveFile(fileName+Common.ENV_TRACE_SUFFIX    ,inStr ,outStr);		recieveFile(fileName+Common.STDOUT_TRACE_SUFFIX ,inStr ,outStr);		recieveFile(fileName+Common.STDERR_TRACE_SUFFIX ,inStr ,outStr);		// done						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);	    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	return Integer.toString(status);    }	    public void CMDCLEAN(String processID) throws Exception {	int status = 0;	if (!inEvaluationMode()) {	    try {		/* Open a socket with the Agent */		openAgentSocket();						TestObject test = (TestObject)executeRequests.get(new Integer(processID));						/* send the CMDCLEAN command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.CMDCLEAN_REQUEST);		test.writeObject(outStr);		outStr.flush();						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	// now remove this entry from our hash table	executeRequests.remove(new Integer(processID));    }	    public void DAEMONCLEAN() throws Exception {	int status = 0;	if (!inEvaluationMode()) {	    try {		/* Open a socket with the Agent */		openAgentSocket();										/* send the DAEMONCLEAN command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.DAEMONCLEAN_REQUEST);		outStr.flush();						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}    }	    public String ENVTRACECONTAINS(String processID, String fileName, String grepString) throws Exception {	return TRACECONTAINS(processID, fileName+Common.ENV_TRACE_SUFFIX, grepString);    }	    public String STDOUTCONTAINS(String processID, String fileName, String grepString) throws Exception {	return TRACECONTAINS(processID, fileName+Common.STDOUT_TRACE_SUFFIX, grepString);    }	    public String STDERRCONTAINS(String processID, String fileName, String grepString) throws Exception {	return TRACECONTAINS(processID, fileName+Common.STDERR_TRACE_SUFFIX, grepString);    }	    private String TRACECONTAINS(String processID, String fileName, String grepString) throws Exception {	int status = 0;	if (!inEvaluationMode()) {							    if (!fileContains(fileName, grepString)) {		status = 1;	    }	}	return Integer.toString(status);    }	    public String[] GETTRACEPATHS(String processID) throws Exception {			int status = 0;	String result[] = new String[3];	TestObject test = (TestObject)executeRequests.get(new Integer(processID));	if (!inEvaluationMode()) {			    try {		/* Open a socket with the Agent */		openAgentSocket();						/* send the GETTRACEPATHS command, and the TestObject,		   and wait for acknowledgment */		outStr.writeInt(ProtocolConstants.GETTRACEPATHS_REQUEST);						test.writeObject(outStr);		outStr.flush();						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,"No process matching this Id was found");						// recieve the stdout and stderr files		result[0] = inStr.readUTF();		result[1] = inStr.readUTF();		result[2] = inStr.readUTF();						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);	    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }	}	else {			    result[0] = test.getEnvFileName().toString();	    result[1] = test.getStdOutFileName().toString();	    result[2] = test.getStdErrFileName().toString();	}	return result;    }	    private boolean fileContains(String fileName, String grepString) throws Exception {	BufferedReader in = new BufferedReader(new FileReader(fileName));	String line;	while((line = in.readLine())!=null) {	    if (line.indexOf(grepString)>=0) {		in.close();		return true;	    }	}	in.close();	return false;    }    /**     * This method will kill all process running in this agent, whether related to this AgentInstace or not.     */    public void KILLALL() throws Exception {	/* Open a socket with the Agent */	if (!inEvaluationMode()) {			    try {		openAgentSocket();						// send the action code		outStr.writeInt(ProtocolConstants.KILLALL);						expectCode(ProtocolConstants.RESPONSE_PROCESSING,RESPONSE_PROCESSING_ERROR);						expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);					    }	    finally {		/* close socket and return the result */		closeAgentSocket();	    }		}    }	    /**     * This method will kill any processes started by this AgentInstance, but will leave others running      * in the agent alone. Also cleans the corresponding traces files created     * by the started processes.     */    public void KILLSTARTEDPROCESSES() throws Exception {	DELAGENT(); // automatically kills any running processes and cleans their traces    }	    private synchronized void recieveFile(String destName, DataInputStream in, DataOutputStream out) throws Exception {	// now read the associatedbytes and write them to file	long counter = 0;	long size = in.readLong();	if ((new File(destName)).exists()) {	    Utils.delete(destName);	}	else {	    Utils.touch(destName);	}	if (size>0) {	    BufferedOutputStream outStream = new BufferedOutputStream(new FileOutputStream(destName));	    try {		byte buff[] = new byte[1024];		int bytesRead = 0;		while ((bytesRead>=0)&&(counter < size)) {		    bytesRead = in.read(buff,0,(((size-counter)<buff.length) ? (int)(size-counter) : buff.length));		    if (bytesRead>0) {			outStream.write(buff,0,bytesRead);			counter+=bytesRead;		    }		}		outStream.flush();	    }	    catch (IOException e) {		e.printStackTrace();	    }	    finally {		outStream.close();	    }	}	int status = in.readInt();	if (status != ProtocolConstants.RESPONSE_FINISHED_OK) {	    throw new Exception("Error recieving file "+destName+" Got status :"+status);	}    }	    private synchronized void sendFile(String srcName, DataInputStream in, DataOutputStream out) throws Exception {	// open the zip file to read	File file;	BufferedInputStream inBuffStr = new BufferedInputStream(new FileInputStream(file = new File(srcName)));	/* send the file length */	out.writeLong(file.length());			/* sends the file content */	BufferedOutputStream outBuffStr = new BufferedOutputStream(out);	int bytesRead=0, counter=0;	long size = file.length();	byte buff[] = new byte[1024];	while ((bytesRead>=0)&&(counter < size)) {	    bytesRead = inBuffStr.read(buff,0,buff.length);	    if (bytesRead>0)		outBuffStr.write(buff,0,bytesRead);	    counter+= bytesRead;	}	outBuffStr.flush();			inBuffStr.close();			expectCode(ProtocolConstants.RESPONSE_FINISHED_OK,RESPONSE_OK_ERROR);    }         private void expectCode(int code, String errorMessage) throws Exception {	int recieved;	if ((recieved=inStr.readInt())!=code) {	    throw new Exception(errorMessage+"(Recieved "+recieved+" instead of "+code+")");	}    }}